dc7af7a1ea4a20338e6498ccfc61cc4e
"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.LinearGradient = void 0;var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _NativeLinearGradient = _interopRequireDefault(require("./NativeLinearGradient"));var _excluded = ["colors", "locations", "start", "end"];function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = (0, _getPrototypeOf2.default)(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return (0, _possibleConstructorReturn2.default)(this, result);};}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;} catch (e) {return false;}}var



LinearGradient = function (_React$Component) {(0, _inherits2.default)(LinearGradient, _React$Component);var _super = _createSuper(LinearGradient);function LinearGradient() {(0, _classCallCheck2.default)(this, LinearGradient);return _super.apply(this, arguments);}(0, _createClass2.default)(LinearGradient, [{ key: "render", value:
    function render() {
      var _this$props = this.props,colors = _this$props.colors,locations = _this$props.locations,start = _this$props.start,end = _this$props.end,props = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
      var resolvedLocations = locations;
      if (locations && colors.length !== locations.length) {
        console.warn('LinearGradient colors and locations props should be arrays of the same length');
        resolvedLocations = locations.slice(0, colors.length);
      }
      return React.createElement(_NativeLinearGradient.default, (0, _extends2.default)({}, props, { colors: _reactNative.Platform.select({
          web: colors,
          default: colors.map(_reactNative.processColor) }),
        locations: resolvedLocations, startPoint: _normalizePoint(start), endPoint: _normalizePoint(end) }));
    } }]);return LinearGradient;}(React.Component);exports.LinearGradient = LinearGradient;

function _normalizePoint(point) {
  if (!point) {
    return undefined;
  }
  if (Array.isArray(point) && point.length !== 2) {
    console.warn('start and end props for LinearGradient must be of the format [x,y] or {x, y}');
    return undefined;
  }
  return Array.isArray(point) ? point : [point.x, point.y];
}