237f38b8deb7a8ff370cdde7faa730ce










'use strict';var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _NativeEventEmitter = _interopRequireDefault(require("../../EventEmitter/NativeEventEmitter"));

var _NativeAnimatedModule = _interopRequireDefault(require("./NativeAnimatedModule"));







var _invariant = _interopRequireDefault(require("invariant"));

var __nativeAnimatedNodeTagCount = 1;
var __nativeAnimationIdCount = 1;

var nativeEventEmitter;

var queueConnections = false;
var queue = [];





var API = {
  enableQueue: function enableQueue() {
    queueConnections = true;
  },
  disableQueue: function disableQueue() {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    queueConnections = false;
    for (var q = 0, l = queue.length; q < l; q++) {
      var args = queue[q];
      _NativeAnimatedModule.default.connectAnimatedNodes(args[0], args[1]);
    }
    queue.length = 0;
  },
  createAnimatedNode: function createAnimatedNode(tag, config) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.createAnimatedNode(tag, config);
  },
  startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.startListeningToAnimatedNodeValue(tag);
  },
  stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.stopListeningToAnimatedNodeValue(tag);
  },
  connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    if (queueConnections) {
      queue.push([parentTag, childTag]);
      return;
    }
    _NativeAnimatedModule.default.connectAnimatedNodes(parentTag, childTag);
  },
  disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.disconnectAnimatedNodes(parentTag, childTag);
  },
  startAnimatingNode: function startAnimatingNode(
  animationId,
  nodeTag,
  config,
  endCallback)
  {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.startAnimatingNode(
    animationId,
    nodeTag,
    config,
    endCallback);

  },
  stopAnimation: function stopAnimation(animationId) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.stopAnimation(animationId);
  },
  setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.setAnimatedNodeValue(nodeTag, value);
  },
  setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.setAnimatedNodeOffset(nodeTag, offset);
  },
  flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.flattenAnimatedNodeOffset(nodeTag);
  },
  extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.extractAnimatedNodeOffset(nodeTag);
  },
  connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.connectAnimatedNodeToView(nodeTag, viewTag);
  },
  disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(
  nodeTag,
  viewTag)
  {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.disconnectAnimatedNodeFromView(nodeTag, viewTag);
  },
  restoreDefaultValues: function restoreDefaultValues(nodeTag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');

    if (_NativeAnimatedModule.default.restoreDefaultValues != null) {
      _NativeAnimatedModule.default.restoreDefaultValues(nodeTag);
    }
  },
  dropAnimatedNode: function dropAnimatedNode(tag) {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.dropAnimatedNode(tag);
  },
  addAnimatedEventToView: function addAnimatedEventToView(
  viewTag,
  eventName,
  eventMapping)
  {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.addAnimatedEventToView(
    viewTag,
    eventName,
    eventMapping);

  },
  removeAnimatedEventFromView: function removeAnimatedEventFromView(
  viewTag,
  eventName,
  animatedNodeTag)
  {
    (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
    _NativeAnimatedModule.default.removeAnimatedEventFromView(
    viewTag,
    eventName,
    animatedNodeTag);

  } };








var STYLES_WHITELIST = {
  opacity: true,
  transform: true,
  borderRadius: true,
  borderBottomEndRadius: true,
  borderBottomLeftRadius: true,
  borderBottomRightRadius: true,
  borderBottomStartRadius: true,
  borderTopEndRadius: true,
  borderTopLeftRadius: true,
  borderTopRightRadius: true,
  borderTopStartRadius: true,
  elevation: true,
  zIndex: true,

  shadowOpacity: true,
  shadowRadius: true,

  scaleX: true,
  scaleY: true,
  translateX: true,
  translateY: true };


var TRANSFORM_WHITELIST = {
  translateX: true,
  translateY: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  rotate: true,
  rotateX: true,
  rotateY: true,
  rotateZ: true,
  perspective: true };


var SUPPORTED_INTERPOLATION_PARAMS = {
  inputRange: true,
  outputRange: true,
  extrapolate: true,
  extrapolateRight: true,
  extrapolateLeft: true };


function addWhitelistedStyleProp(prop) {
  STYLES_WHITELIST[prop] = true;
}

function addWhitelistedTransformProp(prop) {
  TRANSFORM_WHITELIST[prop] = true;
}

function addWhitelistedInterpolationParam(param) {
  SUPPORTED_INTERPOLATION_PARAMS[param] = true;
}

function validateTransform(
configs)













{
  configs.forEach(function (config) {
    if (!TRANSFORM_WHITELIST.hasOwnProperty(config.property)) {
      throw new Error("Property '" +

      config.property + "' is not supported by native animated module");


    }
  });
}

function validateStyles(styles) {
  for (var _key in styles) {
    if (!STYLES_WHITELIST.hasOwnProperty(_key)) {
      throw new Error("Style property '" +
      _key + "' is not supported by native animated module");

    }
  }
}

function validateInterpolation(config) {
  for (var _key2 in config) {
    if (!SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(_key2)) {
      throw new Error("Interpolation property '" +
      _key2 + "' is not supported by native animated module");

    }
  }
}

function generateNewNodeTag() {
  return __nativeAnimatedNodeTagCount++;
}

function generateNewAnimationId() {
  return __nativeAnimationIdCount++;
}

function assertNativeAnimatedModule() {
  (0, _invariant.default)(_NativeAnimatedModule.default, 'Native animated module is not available');
}

var _warnedMissingNativeAnimated = false;

function shouldUseNativeDriver(
config)
{
  if (config.useNativeDriver == null) {
    console.warn(
    'Animated: `useNativeDriver` was not specified. This is a required ' +
    'option and must be explicitly set to `true` or `false`');

  }

  if (config.useNativeDriver === true && !_NativeAnimatedModule.default) {
    if (!_warnedMissingNativeAnimated) {
      console.warn(
      'Animated: `useNativeDriver` is not supported because the native ' +
      'animated module is missing. Falling back to JS-based animation. To ' +
      'resolve this, add `RCTAnimation` module to this app, or remove ' +
      '`useNativeDriver`. ' +
      'Make sure to run `pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md');

      _warnedMissingNativeAnimated = true;
    }
    return false;
  }

  return config.useNativeDriver || false;
}

function transformDataType(value) {


  if (typeof value !== 'string') {
    return value;
  }
  if (/deg$/.test(value)) {
    var degrees = parseFloat(value) || 0;
    var radians = degrees * Math.PI / 180.0;
    return radians;
  } else {
    return value;
  }
}

module.exports = {
  API: API,
  addWhitelistedStyleProp: addWhitelistedStyleProp,
  addWhitelistedTransformProp: addWhitelistedTransformProp,
  addWhitelistedInterpolationParam: addWhitelistedInterpolationParam,
  validateStyles: validateStyles,
  validateTransform: validateTransform,
  validateInterpolation: validateInterpolation,
  generateNewNodeTag: generateNewNodeTag,
  generateNewAnimationId: generateNewAnimationId,
  assertNativeAnimatedModule: assertNativeAnimatedModule,
  shouldUseNativeDriver: shouldUseNativeDriver,
  transformDataType: transformDataType,

  get nativeEventEmitter() {
    if (!nativeEventEmitter) {
      nativeEventEmitter = new _NativeEventEmitter.default(_NativeAnimatedModule.default);
    }
    return nativeEventEmitter;
  } };