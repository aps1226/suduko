e58a49a838ddbb54b136d57b02e6a681
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _excluded = ["name", "color", "size"];
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.accessibilityProps = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var MaterialCommunityIcons;

try {
  MaterialCommunityIcons = require("@expo/vector-icons/MaterialCommunityIcons").default;
} catch (e) {
  var isErrorLogged = false;

  MaterialCommunityIcons = function MaterialCommunityIcons(_ref) {
    var name = _ref.name,
        color = _ref.color,
        size = _ref.size,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    if (!isErrorLogged) {
      if (!/(Cannot find module|Module not found|Cannot resolve module)/.test(e.message)) {
        console.error(e);
      }

      console.warn("Tried to use the icon '".concat(name, "' in a component from 'react-native-paper', but 'react-native-vector-icons/MaterialCommunityIcons' could not be loaded."), "To remove this warning, try installing 'react-native-vector-icons' or use another method to specify icon: https://callstack.github.io/react-native-paper/icons.html.");
      isErrorLogged = true;
    }

    return React.createElement(_reactNative.Text, _extends({}, rest, {
      style: [styles.icon, {
        color: color,
        fontSize: size
      }],
      pointerEvents: "none",
      selectable: false
    }), "\u25A1");
  };
}

var accessibilityProps = _reactNative.Platform.OS === 'web' ? {
  role: 'img',
  focusable: false
} : {
  accessibilityElementsHidden: true,
  importantForAccessibility: 'no-hide-descendants'
};
exports.accessibilityProps = accessibilityProps;

var defaultIcon = function defaultIcon(_ref2) {
  var name = _ref2.name,
      color = _ref2.color,
      size = _ref2.size,
      direction = _ref2.direction,
      allowFontScaling = _ref2.allowFontScaling;
  return React.createElement(MaterialCommunityIcons, _extends({
    allowFontScaling: allowFontScaling,
    name: name,
    color: color,
    size: size,
    style: [{
      transform: [{
        scaleX: direction === 'rtl' ? -1 : 1
      }],
      lineHeight: size
    }, styles.icon],
    pointerEvents: "none",
    selectable: false
  }, accessibilityProps));
};

var styles = _reactNative.StyleSheet.create({
  icon: {
    backgroundColor: 'transparent'
  }
});

var _default = defaultIcon;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk1hdGVyaWFsQ29tbXVuaXR5SWNvbi50c3giXSwibmFtZXMiOlsiTWF0ZXJpYWxDb21tdW5pdHlJY29ucyIsInJlcXVpcmUiLCJpc0Vycm9yTG9nZ2VkIiwicmVzdCIsImUiLCJjb25zb2xlIiwic3R5bGVzIiwiY29sb3IiLCJmb250U2l6ZSIsInNpemUiLCJhY2Nlc3NpYmlsaXR5UHJvcHMiLCJyb2xlIiwiZm9jdXNhYmxlIiwiYWNjZXNzaWJpbGl0eUVsZW1lbnRzSGlkZGVuIiwiaW1wb3J0YW50Rm9yQWNjZXNzaWJpbGl0eSIsImRlZmF1bHRJY29uIiwiYWxsb3dGb250U2NhbGluZyIsInRyYW5zZm9ybSIsInNjYWxlWCIsImRpcmVjdGlvbiIsImxpbmVIZWlnaHQiLCJpY29uIiwiYmFja2dyb3VuZENvbG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxJQUFBLEtBQUEsR0FBQSx1QkFBQSxDQUFBLE9BQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsR0FBQSxPQUFBLENBQUEsY0FBQSxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVQSxJQUFBLHNCQUFBOztBQVNBLElBQUk7QUFFRkEsRUFBQUEsc0JBQXNCLEdBQUdDLE9BQUFBLDZDQUFBQSxDQUF6QkQsT0FBQUE7QUFGRixDQUFBLENBSUUsT0FBQSxDQUFBLEVBQVU7QUFDVixNQUFJRSxhQUFhLEdBRFAsS0FDVjs7QUFHQUYsRUFBQUEsc0JBQXNCLEdBQUcsc0NBQW9DO0FBQUEsUUFBbkMsSUFBbUMsUUFBbkMsSUFBbUM7QUFBQSxRQUFuQyxLQUFtQyxRQUFuQyxLQUFtQztBQUFBLFFBQW5DLElBQW1DLFFBQW5DLElBQW1DO0FBQUEsUUFBWEcsSUFBVzs7QUFFM0QsUUFBSSxDQUFKLGFBQUEsRUFBb0I7QUFDbEIsVUFDRSxDQUFDLDhEQUFBLElBQUEsQ0FDQ0MsQ0FBQyxDQUZMLE9BQ0csQ0FESCxFQUlFO0FBQ0FDLFFBQUFBLE9BQU8sQ0FBUEEsS0FBQUEsQ0FBQUEsQ0FBQUE7QUFDRDs7QUFFREEsTUFBQUEsT0FBTyxDQUFQQSxJQUFBQSxDQUFBQSwwQkFBQUEsTUFBQUEsQ0FBQUEsSUFBQUEsRUFBQUEseUhBQUFBLENBQUFBLEVBQUFBLHNLQUFBQTtBQUtBSCxNQUFBQSxhQUFhLEdBQWJBLElBQUFBO0FBQ0Q7O0FBRUQsV0FDRSxLQUFBLENBQUEsYUFBQSxDQUFDLFlBQUEsQ0FBRCxJQUFBLEVBQUEsUUFBQSxDQUFBLEVBQUEsRUFBQSxJQUFBLEVBQUE7QUFFRSxNQUFBLEtBQUssRUFBRSxDQUFDSSxNQUFNLENBQVAsSUFBQSxFQUFjO0FBQUVDLFFBQUFBLEtBQUYsRUFBRUEsS0FBRjtBQUFTQyxRQUFBQSxRQUFRLEVBQUVDO0FBQW5CLE9BQWQsQ0FGVDtBQUlFLE1BQUEsYUFBYSxFQUpmLE1BQUE7QUFLRSxNQUFBLFVBQVUsRUFBRTtBQUxkLEtBQUEsQ0FBQSxFQURGLFFBQ0UsQ0FERjtBQW5CRlQsR0FBQUE7QUErQkQ7O0FBRU0sSUFBTVUsa0JBQWtCLEdBQzdCLFlBQUEsQ0FBQSxRQUFBLENBQUEsRUFBQSxLQUFBLEtBQUEsR0FDSTtBQUNFQyxFQUFBQSxJQUFJLEVBRE4sS0FBQTtBQUVFQyxFQUFBQSxTQUFTLEVBQUU7QUFGYixDQURKLEdBS0k7QUFDRUMsRUFBQUEsMkJBQTJCLEVBRDdCLElBQUE7QUFFRUMsRUFBQUEseUJBQXlCLEVBQUU7QUFGN0IsQ0FOQzs7O0FBV1AsSUFBTUMsV0FBVyxHQUFHLFNBQWRBLFdBQWM7QUFBQSxNQUFDLElBQUQsU0FBQyxJQUFEO0FBQUEsTUFBQyxLQUFELFNBQUMsS0FBRDtBQUFBLE1BQUMsSUFBRCxTQUFDLElBQUQ7QUFBQSxNQUFDLFNBQUQsU0FBQyxTQUFEO0FBQUEsTUFLbEJDLGdCQUxrQixTQUtsQkEsZ0JBTGtCO0FBQUEsU0FPbEIsS0FBQSxDQUFBLGFBQUEsQ0FBQSxzQkFBQSxFQUFBLFFBQUEsQ0FBQTtBQUNFLElBQUEsZ0JBQWdCLEVBRGxCLGdCQUFBO0FBRUUsSUFBQSxJQUFJLEVBRk4sSUFBQTtBQUdFLElBQUEsS0FBSyxFQUhQLEtBQUE7QUFJRSxJQUFBLElBQUksRUFKTixJQUFBO0FBS0UsSUFBQSxLQUFLLEVBQUUsQ0FDTDtBQUNFQyxNQUFBQSxTQUFTLEVBQUUsQ0FBQztBQUFFQyxRQUFBQSxNQUFNLEVBQUVDLFNBQVMsS0FBVEEsS0FBQUEsR0FBc0IsQ0FBdEJBLENBQUFBLEdBQTJCO0FBQXJDLE9BQUQsQ0FEYjtBQUVFQyxNQUFBQSxVQUFVLEVBQUVYO0FBRmQsS0FESyxFQUtMSCxNQUFNLENBVlYsSUFLUyxDQUxUO0FBWUUsSUFBQSxhQUFhLEVBWmYsTUFBQTtBQWFFLElBQUEsVUFBVSxFQUFFO0FBYmQsR0FBQSxFQVBGLGtCQU9FLENBQUEsQ0FQa0I7QUFBQSxDQUFwQjs7QUF5QkEsSUFBTUEsTUFBTSxHQUFHLFlBQUEsQ0FBQSxVQUFBLENBQUEsTUFBQSxDQUFrQjtBQUMvQmUsRUFBQUEsSUFBSSxFQUFFO0FBQ0pDLElBQUFBLGVBQWUsRUFBRTtBQURiO0FBRHlCLENBQWxCLENBQWY7O2VBTWVQLFciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTdHlsZVNoZWV0LCBUZXh0LCBQbGF0Zm9ybSwgVGV4dFByb3BzLCBWaWV3UHJvcHMgfSBmcm9tICdyZWFjdC1uYXRpdmUnO1xuXG5leHBvcnQgdHlwZSBJY29uUHJvcHMgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgY29sb3I6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyO1xuICBkaXJlY3Rpb246ICdydGwnIHwgJ2x0cic7XG4gIGFsbG93Rm9udFNjYWxpbmc/OiBib29sZWFuO1xufTtcblxubGV0IE1hdGVyaWFsQ29tbXVuaXR5SWNvbnM6IFJlYWN0LkNvbXBvbmVudFR5cGU8XG4gIFRleHRQcm9wcyAmIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sb3I6IHN0cmluZztcbiAgICBzaXplOiBudW1iZXI7XG4gICAgcG9pbnRlckV2ZW50cz86IFZpZXdQcm9wc1sncG9pbnRlckV2ZW50cyddO1xuICB9XG4+O1xuXG50cnkge1xuICAvLyBPcHRpb25hbGx5IHJlcXVpcmUgdmVjdG9yLWljb25zXG4gIE1hdGVyaWFsQ29tbXVuaXR5SWNvbnMgPSByZXF1aXJlKCdyZWFjdC1uYXRpdmUtdmVjdG9yLWljb25zL01hdGVyaWFsQ29tbXVuaXR5SWNvbnMnKVxuICAgIC5kZWZhdWx0O1xufSBjYXRjaCAoZSkge1xuICBsZXQgaXNFcnJvckxvZ2dlZCA9IGZhbHNlO1xuXG4gIC8vIEZhbGxiYWNrIGNvbXBvbmVudCBmb3IgaWNvbnNcbiAgTWF0ZXJpYWxDb21tdW5pdHlJY29ucyA9ICh7IG5hbWUsIGNvbG9yLCBzaXplLCAuLi5yZXN0IH0pID0+IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKCFpc0Vycm9yTG9nZ2VkKSB7XG4gICAgICBpZiAoXG4gICAgICAgICEvKENhbm5vdCBmaW5kIG1vZHVsZXxNb2R1bGUgbm90IGZvdW5kfENhbm5vdCByZXNvbHZlIG1vZHVsZSkvLnRlc3QoXG4gICAgICAgICAgZS5tZXNzYWdlXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBUcmllZCB0byB1c2UgdGhlIGljb24gJyR7bmFtZX0nIGluIGEgY29tcG9uZW50IGZyb20gJ3JlYWN0LW5hdGl2ZS1wYXBlcicsIGJ1dCAncmVhY3QtbmF0aXZlLXZlY3Rvci1pY29ucy9NYXRlcmlhbENvbW11bml0eUljb25zJyBjb3VsZCBub3QgYmUgbG9hZGVkLmAsXG4gICAgICAgIGBUbyByZW1vdmUgdGhpcyB3YXJuaW5nLCB0cnkgaW5zdGFsbGluZyAncmVhY3QtbmF0aXZlLXZlY3Rvci1pY29ucycgb3IgdXNlIGFub3RoZXIgbWV0aG9kIHRvIHNwZWNpZnkgaWNvbjogaHR0cHM6Ly9jYWxsc3RhY2suZ2l0aHViLmlvL3JlYWN0LW5hdGl2ZS1wYXBlci9pY29ucy5odG1sLmBcbiAgICAgICk7XG5cbiAgICAgIGlzRXJyb3JMb2dnZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8VGV4dFxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgc3R5bGU9e1tzdHlsZXMuaWNvbiwgeyBjb2xvciwgZm9udFNpemU6IHNpemUgfV19XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRleHQgZG9lc24ndCBzdXBwb3J0IHRoaXMsIGJ1dCBpdCBzZWVtcyB0byBhZmZlY3QgVG91Y2hhYmxlTmF0aXZlRmVlZGJhY2tcbiAgICAgICAgcG9pbnRlckV2ZW50cz1cIm5vbmVcIlxuICAgICAgICBzZWxlY3RhYmxlPXtmYWxzZX1cbiAgICAgID5cbiAgICAgICAg4pahXG4gICAgICA8L1RleHQ+XG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGFjY2Vzc2liaWxpdHlQcm9wcyA9XG4gIFBsYXRmb3JtLk9TID09PSAnd2ViJ1xuICAgID8ge1xuICAgICAgICByb2xlOiAnaW1nJyxcbiAgICAgICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgYWNjZXNzaWJpbGl0eUVsZW1lbnRzSGlkZGVuOiB0cnVlLFxuICAgICAgICBpbXBvcnRhbnRGb3JBY2Nlc3NpYmlsaXR5OiAnbm8taGlkZS1kZXNjZW5kYW50cycgYXMgJ25vLWhpZGUtZGVzY2VuZGFudHMnLFxuICAgICAgfTtcblxuY29uc3QgZGVmYXVsdEljb24gPSAoe1xuICBuYW1lLFxuICBjb2xvcixcbiAgc2l6ZSxcbiAgZGlyZWN0aW9uLFxuICBhbGxvd0ZvbnRTY2FsaW5nLFxufTogSWNvblByb3BzKSA9PiAoXG4gIDxNYXRlcmlhbENvbW11bml0eUljb25zXG4gICAgYWxsb3dGb250U2NhbGluZz17YWxsb3dGb250U2NhbGluZ31cbiAgICBuYW1lPXtuYW1lfVxuICAgIGNvbG9yPXtjb2xvcn1cbiAgICBzaXplPXtzaXplfVxuICAgIHN0eWxlPXtbXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybTogW3sgc2NhbGVYOiBkaXJlY3Rpb24gPT09ICdydGwnID8gLTEgOiAxIH1dLFxuICAgICAgICBsaW5lSGVpZ2h0OiBzaXplLFxuICAgICAgfSxcbiAgICAgIHN0eWxlcy5pY29uLFxuICAgIF19XG4gICAgcG9pbnRlckV2ZW50cz1cIm5vbmVcIlxuICAgIHNlbGVjdGFibGU9e2ZhbHNlfVxuICAgIHsuLi5hY2Nlc3NpYmlsaXR5UHJvcHN9XG4gIC8+XG4pO1xuXG5jb25zdCBzdHlsZXMgPSBTdHlsZVNoZWV0LmNyZWF0ZSh7XG4gIGljb246IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdEljb247XG4iXX0=