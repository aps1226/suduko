{"version":3,"sources":["LogBoxData.js"],"names":["observers","Set","ignorePatterns","appInfo","logs","updateTimeout","_isDisabled","_selectedIndex","warningFilter","format","finalFormat","forceDialogImmediately","suppressDialog_LEGACY","suppressCompletely","monitorEvent","monitorListVersion","monitorSampleRate","LOGBOX_ERROR_MESSAGE","getNextState","isDisabled","selectedLogIndex","reportLogBoxError","error","componentStack","ExceptionsManager","require","forceRedbox","message","handleException","isLogBoxErrorMessage","includes","isMessageIgnored","pattern","RegExp","test","handleUpdate","setImmediate","nextState","forEach","observer","appendNewLog","newLog","content","lastLog","Array","from","pop","category","incrementCount","level","OPTIMISTIC_WAIT_TIME","addPendingLog","add","setSelectedLog","size","optimisticTimeout","setTimeout","symbolicate","status","clearTimeout","addLog","log","errorForStackTrace","Error","stack","LogBoxLog","isComponentError","addException","loggingError","symbolicateLogNow","retrySymbolicateLogNow","retrySymbolicate","symbolicateLogLazy","clear","proposedNewIndex","oldIndex","newIndex","logArray","index","length","NativeLogBox","show","hide","clearWarnings","newLogs","filter","clearErrors","dismiss","has","delete","setWarningFilter","setAppInfo","info","getAppInfo","checkWarningFilter","addIgnorePatterns","patterns","newPatterns","entries","existingPattern","toString","setDisabled","value","observe","subscription","unsubscribe","withSubscription","WrappedComponent","LogBoxStateSubscription","state","hasError","_handleDismiss","stateLogs","logsArray","_handleMinimize","_handleSetSelectedLog","err","errorInfo","_subscription","data","setState","React","Component"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n('use strict');\n\nimport * as React from 'react';\nimport LogBoxLog from './LogBoxLog';\nimport {parseLogBoxException} from './parseLogBoxLog';\nimport type {LogLevel} from './LogBoxLog';\nimport type {\n  Message,\n  Category,\n  ComponentStack,\n  ExtendedExceptionData,\n} from './parseLogBoxLog';\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\nimport type {ExtendedError} from '../../Core/Devtools/parseErrorStack';\nimport NativeLogBox from '../../NativeModules/specs/NativeLogBox';\nexport type LogBoxLogs = Set<LogBoxLog>;\nexport type LogData = $ReadOnly<{|\n  level: LogLevel,\n  message: Message,\n  category: Category,\n  componentStack: ComponentStack,\n|}>;\n\nexport type Observer = (\n  $ReadOnly<{|\n    logs: LogBoxLogs,\n    isDisabled: boolean,\n    selectedLogIndex: number,\n  |}>,\n) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = $ReadOnly<{|\n  unsubscribe: () => void,\n|}>;\n\nexport type WarningInfo = {|\n  finalFormat: string,\n  forceDialogImmediately: boolean,\n  suppressDialog_LEGACY: boolean,\n  suppressCompletely: boolean,\n  monitorEvent: string | null,\n  monitorListVersion: number,\n  monitorSampleRate: number,\n|};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype AppInfo = $ReadOnly<{|\n  appVersion: string,\n  engine: string,\n  onPress?: ?() => void,\n|}>;\n\nconst observers: Set<{observer: Observer, ...}> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet appInfo: ?() => AppInfo = null;\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nlet warningFilter: WarningFilter = function(format) {\n  return {\n    finalFormat: format,\n    forceDialogImmediately: false,\n    suppressDialog_LEGACY: true,\n    suppressCompletely: false,\n    monitorEvent: 'unknown',\n    monitorListVersion: 0,\n    monitorSampleRate: 1,\n  };\n};\n\nconst LOGBOX_ERROR_MESSAGE =\n  'An error was thrown when attempting to render log messages via LogBox.';\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(\n  error: ExtendedError,\n  componentStack?: string,\n): void {\n  const ExceptionsManager = require('../../Core/ExceptionsManager');\n\n  error.forceRedbox = true;\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error, /* isFatal */ true);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === 'string' && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediate(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({observer}) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog) {\n  // We don't want to store these logs because they trigger a\n  // state update whenever we add them to the store, which is\n  // expensive to noisy logs. If we later want to display these\n  // we will store them in a different state object.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then we want to roll it up into the last log in the list\n  // by incrementing the count (simar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === 'fatal') {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // sybolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog = () => {\n      logs.add(newLog);\n      if (_selectedIndex <= 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    newLog.symbolicate(status => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      // TODO: Use Error.captureStackTrace on Hermes\n      const stack = parseErrorStack(errorForStackTrace);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        }),\n      );\n    } catch (error) {\n      reportLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(log: LogBoxLog) {\n  log.symbolicate(() => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(log: LogBoxLog) {\n  log.retrySymbolicate(() => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(log: LogBoxLog) {\n  log.symbolicate();\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter(\n    log => log.level !== 'error' && log.level !== 'fatal',\n  );\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function setWarningFilter(filter: WarningFilter): void {\n  warningFilter = filter;\n}\n\nexport function setAppInfo(info: () => AppInfo): void {\n  appInfo = info;\n}\n\nexport function getAppInfo(): ?AppInfo {\n  return appInfo != null ? appInfo() : null;\n}\n\nexport function checkWarningFilter(format: string): WarningInfo {\n  return warningFilter(format);\n}\n\nexport function addIgnorePatterns(\n  patterns: $ReadOnlyArray<IgnorePattern>,\n): void {\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  const newPatterns = patterns.filter((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns.entries()) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return !ignorePatterns.has(pattern);\n  });\n\n  if (newPatterns.length === 0) {\n    return;\n  }\n  for (const pattern of newPatterns) {\n    ignorePatterns.add(pattern);\n\n    // We need to recheck all of the existing logs.\n    // This allows adding an ignore pattern anywhere in the codebase.\n    // Without this, if you ignore a pattern after the a log is created,\n    // then we would keep showing the log.\n    logs = new Set(\n      Array.from(logs).filter(log => !isMessageIgnored(log.message.content)),\n    );\n  }\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = {observer};\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\ntype Props = $ReadOnly<{||}>;\ntype State = $ReadOnly<{|\n  logs: LogBoxLogs,\n  isDisabled: boolean,\n  hasError: boolean,\n  selectedLogIndex: number,\n|}>;\n\ntype SubscribedComponent = React.AbstractComponent<\n  $ReadOnly<{|\n    logs: $ReadOnlyArray<LogBoxLog>,\n    isDisabled: boolean,\n    selectedLogIndex: number,\n  |}>,\n>;\n\nexport function withSubscription(\n  WrappedComponent: SubscribedComponent,\n): React.AbstractComponent<{||}> {\n  class LogBoxStateSubscription extends React.Component<Props, State> {\n    static getDerivedStateFromError() {\n      return {hasError: true};\n    }\n\n    componentDidCatch(err: Error, errorInfo: {componentStack: string, ...}) {\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription: ?Subscription;\n\n    state = {\n      logs: new Set(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    render(): React.Node {\n      if (this.state.hasError) {\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\n        // We can't show anyback fallback UI here, because the error may be with <View> or <Text>.\n        return null;\n      }\n\n      return (\n        <WrappedComponent\n          logs={Array.from(this.state.logs)}\n          isDisabled={this.state.isDisabled}\n          selectedLogIndex={this.state.selectedLogIndex}\n        />\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe(data => {\n        this.setState(data);\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const {selectedLogIndex, logs: stateLogs} = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  return LogBoxStateSubscription;\n}\n"]}