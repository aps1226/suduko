{"C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\Component Tests\\GameDisplay.test.tsx":{"modulePaths":["C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-native\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\renderWithRedux.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\history\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-router\\ts4.0\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@testing-library\\react-native\\typings\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\types.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\state\\reducers\\index.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\components\\GameDisplay.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\react-native-paper\\lib\\typescript\\index.d.ts"],"testFileContent":"import React from 'react';\r\nimport { Text,View } from 'react-native';\r\nimport renderWithRedux from '../renderWithRedux';\r\nimport { createMemoryHistory, createLocation, MemoryHistory, Location} from 'history';\r\nimport { match } from 'react-router';\r\nimport { act, cleanup, fireEvent, render, waitFor} from '@testing-library/react-native';\r\nimport {Colors, GameState, RenderReduxAPI} from '../../../types';\r\nimport {RootState} from '../../state/reducers/index';\r\nimport GameDisplay from '../../../components/GameDisplay';\r\nimport { ToggleButton } from 'react-native-paper';\r\n\r\n//Mock props for routing.\r\nconst history = createMemoryHistory();\r\nconst path:string = `/route/:id`;\r\nconst match: match<{ id: string }> = {\r\n    isExact: false,\r\n    path,\r\n    url: path.replace(':id', '1'),\r\n    params: { id: '1' }\r\n};\r\nconst location = createLocation(match.url);\r\n\r\n//Hard coded state properties.\r\nconst board: (number | null)[][] =[ \r\n  [ 3, 1, 6, 5, 7, 8, 4, 9, 2 ],\r\n  [ 5, 2, 9, 1, 3, 4, 7, 6, 8 ],\r\n  [ 4, 8, 7, 6, 2, 9, 5, 3, 1 ],\r\n  [ 2, 6, 3, 4, 1, 5, 9, 8, 7 ],\r\n  [ 9, 7, 4, 8, 6, null, 1, 2, 5 ],\r\n  [ 8, 5, 1, 7, 9, 2, 6, 4, 3 ],\r\n  [ 1, 3, 8, 9, 4, 7, 2, null, 6 ],\r\n  [ 6, 9, 2, 3, 5, 1, 8, 7, 4 ],\r\n  [ 7, 4, 5, 2, 8, 6, 3, 1, 9] \r\n];\r\n\r\nconst colors:Colors = {\r\n  1:['transparent','black'],\r\n  2:['transparent','black'],\r\n  3:['transparent','black'],\r\n  4:['transparent','black'],\r\n  5:['transparent','black'],\r\n  6:['transparent','black'],\r\n  7:['transparent','black'],\r\n  8:['transparent','black'],\r\n  9:['transparent','black'],\r\n  'Selection_1':'#3297FD',\r\n  'Selection_2':'transparent',\r\n  'Selection_3':'transparent',\r\n  'Selection_4':'transparent',\r\n  'Selection_5':'transparent',\r\n  'Selection_6':'transparent',\r\n  'Selection_7':'transparent',\r\n  'Selection_8':'transparent',\r\n  'Selection_9':'transparent',\r\n  'gradient': [ \r\n    \"#a37e5c\", \"#b89372\",\"#c8a484\",\"#dcb999\", \"#d3af8f\",\"#d9b696\",\"#ceaa89\",\"#d2ae8d\",\"#b38e6d\",\"#aa8563\",\r\n    \"#a37e5c\", \"#b89372\",\"#c8a484\",\"#dcb999\", \"#d3af8f\",\"#d9b696\",\"#ceaa89\",\"#d2ae8d\",\"#b38e6d\",\"#aa8563\",\r\n    \"#a37e5c\", \"#b89372\",\"#c8a484\",\"#dcb999\", \"#d3af8f\",\"#d9b696\",\"#ceaa89\",\"#d2ae8d\",\"#b38e6d\",\"#aa8563\",\r\n    \"#a37e5c\", \"#b89372\",\"#c8a484\",\"#dcb999\", \"#d3af8f\",\"#d9b696\",\"#ceaa89\",\"#d2ae8d\",\"#b38e6d\",\"#aa8563\",\r\n    \"#a37e5c\", \"#b89372\",\"#c8a484\",\"#dcb999\", \"#d3af8f\",\"#d9b696\",\"#ceaa89\",\"#d2ae8d\",\"#b38e6d\",\"#aa8563\"\r\n  ]\r\n}\r\n\r\nconst gameState: GameState = {\r\n  'isCompleted':false,\r\n  'gameExists':true\r\n}\r\n\r\n//GameDisplay component test.\r\ndescribe('GameDisplay',() =>{\r\n\r\n  //Mock store object for state management.\r\n    //Hard code properties that are initialized randomly for\r\n    //snapshot comparison.\r\n  const mockStore:RootState = {\r\n    'board':board,\r\n    'colors':colors,\r\n    'gameState':gameState\r\n  };\r\n\r\n  //Mock switch component.\r\n  jest.mock('react-native/Libraries/Components/Switch/Switch', () => {\r\n    const mockComponent = require('react-native/jest/mockComponent')\r\n    return mockComponent('react-native/Libraries/Components/Switch/Switch')\r\n  })\r\n\r\n  //Render GameDisplay component with routing and redux.\r\n  let gameDisplayComponent:RenderReduxAPI;\r\n  beforeEach(async() =>{\r\n    await waitFor(() =>{\r\n      gameDisplayComponent = renderWithRedux(\r\n        <GameDisplay\r\n          history={history}\r\n          location={location}\r\n          match={match}\r\n        />,\r\n        {\r\n          initialState:mockStore\r\n        }\r\n      );\r\n    })\r\n  })\r\n\r\n  afterEach(cleanup);\r\n\r\n  //Component renders without crashing.\r\n  it('renders without crashing',async()=>{\r\n    expect(gameDisplayComponent.toJSON()).toMatchSnapshot();\r\n  })\r\n\r\n  //Test that board will allow for valid value entry to the board.\r\n  it(`should allow for a square with a null value to be updated with a valid value`, ()=>{\r\n    const {getByTestId,store,queryByTestId} = gameDisplayComponent;\r\n    const selectionSquare5 = getByTestId('selectionSquare_5');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    //Select selection square for 5 value.\r\n    fireEvent.press(selectionSquare5);\r\n    //Input a 5 for the grid square at location row 6, column 7.\r\n    fireEvent.press(gridSquare67);\r\n    //Board should have updated with a 5 at location row 6, column 7.\r\n    expect(store.getState().board[6][7]).toBe(5);\r\n  })\r\n\r\n  //Test that board will not allow for invalid entry to the board.\r\n  it(`should not allow for an invalid entry to the board`, ()=>{\r\n    const {getByTestId,store,queryByTestId} = gameDisplayComponent;\r\n    const selectionSquare4 = getByTestId('selectionSquare_4');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    //Select selection square for 4 value.\r\n    fireEvent.press(selectionSquare4);\r\n    //Input a 5 for the grid square at location row 6, column 7.\r\n    fireEvent.press(gridSquare67);\r\n    //Board should not have updated.\r\n    expect(store.getState().board[6][7]).toBe(null);\r\n  })\r\n\r\n  //Test that board will not allow for a square that already contains a value to be overridden with another value.\r\n  it(`should not allow for a square with an existing value to be overridden with another value`, ()=>{\r\n    const {getByTestId,store,queryByTestId} = gameDisplayComponent;\r\n    const selectionSquare6 = getByTestId('selectionSquare_6');\r\n    const gridSquare00 = getByTestId('gridSquare_00');\r\n    //Select selection square for 6 value.\r\n    fireEvent.press(selectionSquare6);\r\n    //Attempt to input a 6 for the grid square at location row 0, column 0.\r\n    fireEvent.press(gridSquare00);\r\n    //Value should remain the initial value of 3.\r\n    expect(store.getState().board[0][0]).toBe(3);\r\n  })\r\n\r\n  //Test that note entry works.\r\n  it(`should allow for note entry for squares that do not have an inputted value`, ()=>{\r\n    const {getByTestId,store} = gameDisplayComponent;\r\n    //Square with a null value.\r\n    const entryModeToggle = getByTestId('entryModeToggle');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    //Change entry mode to 'Notes' by pressing the toggle switch.\r\n    fireEvent(entryModeToggle,'valueChange',false);\r\n    //Values to input as notes.\r\n    [1,2,3,5,6,7,8,9].forEach((num,index) =>{\r\n      let selection = getByTestId(`selectionSquare_${num}`);\r\n      //Press selection value.\r\n      fireEvent.press(selection);\r\n      //Press square with null value to enter note.\r\n      fireEvent.press(gridSquare67);\r\n      //Assert that note state value was updated.\r\n      expect(store.getState().notes['67'][index]).toBe(num);\r\n    })\r\n  })\r\n\r\n  //Test that a square will not allow for a repeated note entry.\r\n  it(`should not allow for a repeated note entry for a given square`, ()=>{\r\n    const {getByTestId,store} = gameDisplayComponent;\r\n    //Square with a null value.\r\n    const entryModeToggle = getByTestId('entryModeToggle');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    const selection1 = getByTestId(`selectionSquare_1`);\r\n    //Change entry mode to 'Notes' by pressing the toggle switch.\r\n    fireEvent(entryModeToggle,'valueChange',false);\r\n    //Press selection value for '1'.\r\n    fireEvent.press(selection1);\r\n    //Press square with null value to enter note.\r\n    fireEvent.press(gridSquare67);\r\n    //Assert that length of note state for this square is 1.\r\n    expect(store.getState().notes['67'].length).toBe(1);\r\n    //Attempt to re-enter note in null square where note for '1' already exists.\r\n    fireEvent.press(gridSquare67);\r\n    //Assert that length of note state for this square is still 1.\r\n    expect(store.getState().notes['67'].length).toBe(1);\r\n  })\r\n\r\n  //Test that a note cannot be entered in a square containing a valid value.\r\n  it(`should not allow for a note to be entered in a square already containing a valid value`, ()=>{\r\n    const {getByTestId,store} = gameDisplayComponent;\r\n    const entryModeToggle = getByTestId('entryModeToggle');\r\n    const gridSquare00 = getByTestId('gridSquare_00');\r\n    const selection2 = getByTestId(`selectionSquare_2`);\r\n    //Change entry mode to 'Notes' by pressing the toggle switch.\r\n    fireEvent(entryModeToggle,'valueChange',false);\r\n    //Press selection value for '2'.\r\n    fireEvent.press(selection2);\r\n    //Attempt to enter '2' note in a square with an existing value.\r\n    fireEvent.press(gridSquare00);\r\n    //Assert that a note was not inputted.\r\n    expect(store.getState().notes['00']).toBeFalsy();\r\n  })\r\n\r\n  //If board is not complete, winner animation should not be rendered.\r\n  it(`should not render the Winner component if the board is not complete`, async ()=>{\r\n    const {getByTestId,store,queryByTestId} = gameDisplayComponent;\r\n    const selectionSquare5 = getByTestId('selectionSquare_5');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    //Select selection square for 5 value.\r\n    fireEvent.press(selectionSquare5);\r\n    //Input a 5 for the grid square at location row 6, column 7.\r\n    fireEvent.press(gridSquare67);\r\n    //Winner animation should not be found.\r\n    await waitFor(() =>{\r\n      expect(queryByTestId('winnerAnimation')).toBeFalsy();\r\n    })\r\n  })\r\n\r\n  //If board is complete, winner animation should be rendered.\r\n  it(`should render the Winner component if the board is complete`, async ()=>{\r\n    const {getByTestId,store,queryByTestId} = gameDisplayComponent;\r\n    const selectionSquare5 = getByTestId('selectionSquare_5');\r\n    const selectionSquare3 = getByTestId('selectionSquare_3');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    const gridSquare45 = getByTestId('gridSquare_45');\r\n    //Select selection square for 5 value.\r\n    fireEvent.press(selectionSquare5);\r\n    //Input a 5 for the grid square at location row 6, column 7.\r\n    fireEvent.press(gridSquare67);\r\n    //Select selection square for 3 value.\r\n    fireEvent.press(selectionSquare3);\r\n    //Input a 3 for the grid square at location row 4, column 5.\r\n    fireEvent.press(gridSquare45);\r\n    //Winner animation should not be found.\r\n    await waitFor(()=>{\r\n      expect(queryByTestId('winnerAnimation')).toBeTruthy();\r\n    })\r\n  })\r\n\r\n  //If board is completed, pressing the screen should route to the main menu.\r\n  it(`should route to the main menu if the board is completed and the screen is, then, pressed`, async ()=>{\r\n    const {getByTestId,store} = gameDisplayComponent;\r\n    const selectionSquare5 = getByTestId('selectionSquare_5');\r\n    const selectionSquare3 = getByTestId('selectionSquare_3');\r\n    const gridSquare67 = getByTestId('gridSquare_67');\r\n    const gridSquare45 = getByTestId('gridSquare_45');\r\n    const curHistory = history.length;\r\n    //Select selection square for 5 value.\r\n    fireEvent.press(selectionSquare5);\r\n    //Input a 5 for the grid square at location row 6, column 7.\r\n    fireEvent.press(gridSquare67);\r\n    //Select selection square for 3 value.\r\n    fireEvent.press(selectionSquare3);\r\n    //Input a 3 for the grid square at location row 4, column 5.\r\n    fireEvent.press(gridSquare45);\r\n    //Winner animation should not be found.\r\n    await waitFor(()=>{\r\n      //Simulate screen press.\r\n      fireEvent.press(getByTestId('winnerAnimationPressable'));\r\n      //History length should increase by 1.\r\n      expect(history.length).toBe(curHistory + 1);\r\n      //Location pathname should be '/'.\r\n      expect(history.location.pathname).toBe('/');\r\n    })\r\n  })\r\n\r\n  //Test that color highlighting by value works.\r\n  it(`should allow for color highlighting based on value`, async ()=>{\r\n    const {getByTestId, getAllByTestId, store} = gameDisplayComponent;\r\n    const gridSquare00 = getByTestId('gridSquare_00');\r\n    const gridSquareView3Arr = getAllByTestId('gridSquareView_3');\r\n    const gridSquareText3Arr = getAllByTestId('gridSquareText_3');\r\n    //Simulate pressing square at location row 0, column 0.\r\n      //Value is hard coded to be a 3.\r\n    fireEvent.press(gridSquare00);\r\n    await waitFor(()=>{\r\n      //Test that grid squares with values of 3 have been correctly highlighted.\r\n      expect(store.getState().colors['3'][0] === '#008000' && store.getState().colors['3'][1] === '#008000').toBe(true);\r\n      //All view elements containing a value of 3 should have a background color of '#008000'.\r\n      gridSquareView3Arr.map((comp) => expect(comp.props.style.backgroundColor).toBe('#008000'))\r\n      //All text elements containing a value of 3 should have a color of '#008000'.\r\n      gridSquareText3Arr.map((comp) => expect(comp.props.style.color).toBe('#008000'))\r\n    })\r\n  })\r\n\r\n  //Test timer.\r\n  it.skip(`should allow for timer value to increment once every second`, async ()=>{\r\n    const {getByTestId,store} = await gameDisplayComponent;\r\n    //Current time.\r\n    const curTime = store.getState().timer.time;\r\n    //Wait 1 second.\r\n      //Assert that time has increased by 1.\r\n    setTimeout(expect(store.getState().timer.time).toBe(curTime+1),2000);\r\n  })\r\n\r\n  //Test main menu button.\r\n  it(`should route to the main menu when the 'Main Menu' button is selected`,() =>{\r\n    const {getByTestId} = gameDisplayComponent;\r\n    const mainMenuButton = getByTestId('mainMenuButton');\r\n    const curHistory = history.length;\r\n    //Press 'Main Menu' button.\r\n    fireEvent.press(mainMenuButton);\r\n    //History length should increase by 1.\r\n    expect(history.length).toBe(curHistory + 1);\r\n    //Location pathname should be '/'.\r\n    expect(history.location.pathname).toBe('/');\r\n  })\r\n\r\n})"},"C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\Component Tests\\renderWithRedux.tsx":{"modulePaths":["C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\redux\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\redux-thunk\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-redux\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\state\\reducers\\index.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@testing-library\\react-native\\typings\\index.d.ts"],"testFileContent":"import React from 'react';\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport thunk from 'redux-thunk';\r\nimport { Provider } from 'react-redux';\r\nimport reducers from '../../state/reducers/index';\r\nimport { render } from '@testing-library/react-native';\r\n\r\n//Function to provide mockStore for components managed by redux.\r\nexport default function renderWithRedux(\r\n  component:JSX.Element,\r\n  //@ts-ignore\r\n  {initialState,store = createStore(reducers,initialState,applyMiddleware(thunk))} = {}\r\n){\r\n  return {\r\n    ...render(<Provider store = {store}>{component}</Provider>),\r\n    store\r\n  }\r\n}"},"C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\Component Tests\\Home.test.tsx":{"modulePaths":["C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\renderWithRedux.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\history\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-router\\ts4.0\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@testing-library\\react-native\\typings\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\types.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\state\\reducers\\index.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\components\\Home.tsx"],"testFileContent":"import React from 'react';\nimport renderWithRedux from '../renderWithRedux';\nimport { createMemoryHistory, createLocation } from 'history';\nimport { match } from 'react-router'; \nimport { act, cleanup, fireEvent, render, waitFor} from '@testing-library/react-native';\nimport {RenderReduxAPI} from '../../../types';\nimport {RootState} from '../../state/reducers/index';\nimport Home from '../../../components/Home';\n\n//Mock props for routing.\nconst history = createMemoryHistory();\nconst path = `/route/:id`;\nconst match: match<{ id: string }> = {\n    isExact: false,\n    path,\n    url: path.replace(':id', '1'),\n    params: { id: \"1\" }\n};\nconst location = createLocation(match.url);\n\n//Home component testing.\ndescribe('Home', () =>{\n  //Mock store object for state management.\n  const mockStore:RootState = {};\n  //Render Home component with routing and redux.\n  let homeComponent:RenderReduxAPI;\n  beforeEach(() =>{\n    homeComponent = renderWithRedux(\n      <Home\n        history = {history}\n        match = {match}\n        location = {location}\n      />,\n      {\n        initialState: mockStore\n      }\n    );\n  })\n\n  afterEach(cleanup);\n\n  //Home component should match current screenshot.\n  it('renders without crashing', () => {\n    expect(homeComponent.toJSON()).toMatchSnapshot();\n  });\n\n  //Home component should route to the difficulty selection menu when the 'Play New Game' button is selected.\n  it(`routes to difficulty selection menu when pressing 'Play New Game'.`, () => {\n    const {getByTestId} = homeComponent;\n    const newGameButton = getByTestId('newGameButton');\n    const curHistory = history.length;\n    expect(history.length).toBe(curHistory);\n    //Press 'Play New Game' button.\n    fireEvent.press(newGameButton);\n    //History length should increase by 1.\n    expect(history.length).toBe(curHistory + 1);\n    //Location pathname should be 'DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection')\n  });\n\n  //Home component should not route to GameDisplay component when pressing 'Load Game' if a game does not exist.\n  it(`does not route to GameDisplay when pressing 'Load Game' if a game does not exist.`, () => {\n    const {getByTestId} = homeComponent;\n    const loadGameButton = getByTestId('loadGameButton');\n    const curHistory = history.length;\n    expect(history.length).toBe(curHistory);\n    //Location pathname should initially be '/DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection')\n    //Press 'Load Game Button'.\n    fireEvent.press(loadGameButton);\n    //History length should not change.\n    expect(history.length).toBe(curHistory);\n    //Location pathname should remain as '/DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection')\n  });\n\n  //A pop-up prompt should appear when the 'Load Game' button is pressed when no current game exists.\n  it(`prompt appears when attempting to load a game when none exists.`, () => {\n    const {getByTestId} = homeComponent;\n    const loadGameButton = getByTestId('loadGameButton');\n    const loadGamePopUp = getByTestId('loadGamePopUp');\n    //Popup should initially not be visible.\n    expect(loadGamePopUp.props.visible).toBeFalsy();\n    //Press 'Load Game' button.\n    fireEvent.press(loadGameButton);\n    //Popup should no longer be visible.\n    expect(loadGamePopUp.props.visible).toBeTruthy();\n  });\n  \n  //Load game prompt should disappear after the screen is pressed.\n  it(`prompt disappears when pressing the screen.`, async ()=>{\n    const {getByTestId} = homeComponent;\n    const loadGameButton = getByTestId('loadGameButton');\n    const loadGamePopUp = getByTestId('loadGamePopUp');\n    const loadGamePopUpHide = getByTestId('loadGamePopUpHide');\n    //Prompt should initially be invisible.\n    expect(loadGamePopUp.props.visible).toBeFalsy();\n    //Press 'Load Game' button.\n    fireEvent.press(loadGameButton);\n    //Prompt should be visible.\n    expect(loadGamePopUp.props.visible).toBeTruthy();\n    //Press screen after prompt appears.\n    fireEvent.press(loadGamePopUpHide);\n    //Wait for component to update after press event.\n    await waitFor(() => {\n      //Prompt should not be visible.\n      expect(getByTestId('loadGamePopUp').props.visible).toBeFalsy();\n    })\n\n    //Update state for the next series of tests.\n    mockStore['gameState'] = {\n      'isCompleted':false,\n      'gameExists':true\n    }\n\n  })\n\n  \n  //Home component should route to GameDisplay component if a current game exists.\n  it(`routes to GameDisplay when pressing 'Load Game' if a game does exist.`, () => {\n    const {getByTestId, store} = homeComponent;\n    const loadGameButton = getByTestId('loadGameButton');\n    const curHistory = history.length;\n    expect(history.length).toBe(curHistory);\n    //Location pathname should initially be 'DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection')\n    //Press 'Load Game' button.\n    fireEvent.press(loadGameButton);\n    //History length should increase by 1.\n    expect(history.length).toBe(curHistory + 1);\n    //Location pathname should be 'GameDisplay'.\n    expect(history.location.pathname).toBe('/GameDisplay')\n  });\n  \n  //Home component should not immediately route to DifficultySelection component if a game exists.\n  it(`does not route to difficulty selection menu when pressing 'Play New Game' if a game currently exists.`, () => {\n    const {getByTestId} = homeComponent;\n    const newGameButton = getByTestId('newGameButton');\n    const curHistory = history.length;\n    expect(history.length).toBe(curHistory);\n    //Location pathname should initially be 'GameDisplay'.\n    expect(history.location.pathname).toBe('/GameDisplay')\n    //Press 'Play New Game'.\n    fireEvent.press(newGameButton);\n    //History length should remain the same.\n    expect(history.length).toBe(curHistory);\n    //Location pathname should remain as 'GameDisplay'.\n    expect(history.location.pathname).toBe('/GameDisplay')\n  });\n  \n  //Prompt should appear when attempting to play a new game when one currently exists.\n  it(`prompt appears when attempting to play a new game when one exists.`, () => {\n    const {getByTestId} = homeComponent;\n    const newGameButton = getByTestId('newGameButton');\n    const newGamePopUp = getByTestId('newGamePopUp');\n    //Prompt should initially not be visible.\n    expect(newGamePopUp.props.visible).toBeFalsy();\n    //Press 'Play New Game' button.\n    fireEvent.press(newGameButton);\n    //Prompt should be visible.\n    expect(newGamePopUp.props.visible).toBeTruthy();\n  });\n\n  //Home component should route to difficulty selection menu when the 'yes' button is selected within the prompt.\n  it(`should route to the difficulty selection menu when the 'yes' button is selected on the 'Play New Game' popup.`, () =>{\n    const {getByTestId} = homeComponent;\n    const newGameButton = getByTestId('newGameButton');\n    const newGamePopUp = getByTestId('newGamePopUp');\n    const yesButton = getByTestId('newGamePopUpYes');\n    const curHistory = history.length;\n    expect(history.length).toBe(curHistory);\n    //Location pathname should initially be 'GameDisplay'.\n    expect(history.location.pathname).toBe('/GameDisplay');\n    //Press 'Play New Game' button.\n    fireEvent.press(newGameButton);\n    //Press 'Yes' button.\n    fireEvent.press(yesButton);\n    //History length should initially be 6.\n    expect(history.length).toBe(curHistory + 1);\n    //Location pathname should be 'DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection');\n  })\n\n  //When the 'No' button is selected on the prompt it should disappear\n  //and not route to another component.\n  it(`prompt should disappear and not route to any other component when the 'No' button is selected on the prompt.`, async()=>{\n    const {getByTestId} = homeComponent;\n    const newGameButton = getByTestId('newGameButton');\n    const newGamePopUp = getByTestId('newGamePopUp');\n    const noButton = getByTestId('newGamePopUpNo');\n    const curHistory = history.length;\n    expect(history.length).toBe(curHistory);\n    //Location pathname should initially be 'DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection');\n    //Press 'Play New Game' button.\n    fireEvent.press(newGameButton);\n    //Wait for component to update after press event.\n    //'Play New Game' prompt should be visible.\n    await waitFor(() =>{\n      expect(getByTestId('newGamePopUp').props.visible).toBeTruthy();\n    })\n    //Press 'No' button.\n    fireEvent.press(noButton);\n    //Wait for component to update after press event.\n    //'Play New Game' prompt should not be visible.\n    await waitFor(() =>{\n      expect(getByTestId('newGamePopUp').props.visible).toBeFalsy();\n    })\n    //History length should remain the same.\n    expect(history.length).toBe(curHistory);\n    //Location pathname should initially be 'DifficultySelection'.\n    expect(history.location.pathname).toBe('/DifficultySelection');\n  })\n});\n"},"C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\Component Tests\\DifficultySelection.test.tsx":{"modulePaths":["C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-native\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\renderWithRedux.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\history\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-router\\ts4.0\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@testing-library\\react-native\\typings\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\types.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\state\\reducers\\index.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\components\\DifficultySelection.tsx"],"testFileContent":"import React from 'react';\r\nimport { Text,View } from 'react-native';\r\nimport renderWithRedux from '../renderWithRedux';\r\nimport { createMemoryHistory, createLocation, MemoryHistory, Location} from 'history';\r\nimport { match } from 'react-router';\r\nimport { act, cleanup, fireEvent, render, waitFor} from '@testing-library/react-native';\r\nimport {RenderReduxAPI} from '../../../types';\r\nimport {RootState} from '../../state/reducers/index';\r\nimport DifficultySelection from '../../../components/DifficultySelection';\r\n\r\n//Mock props for routing.\r\nconst history = createMemoryHistory();\r\nconst path:string = `/route/:id`;\r\nconst match: match<{ id: string }> = {\r\n    isExact: false,\r\n    path,\r\n    url: path.replace(':id', '1'),\r\n    params: { id: '1' }\r\n};\r\nconst location = createLocation(match.url);\r\n\r\n//DifficultySelection component test.\r\ndescribe('DifficultySelection',() =>{\r\n  //Mock store object for state management.\r\n  const mockStore:RootState = {};\r\n  //Render DifficultySelection component with routing and redux.\r\n  let difficultySelection:RenderReduxAPI;\r\n  beforeEach(async() =>{\r\n    await waitFor(() =>{\r\n      difficultySelection = renderWithRedux(\r\n        <DifficultySelection\r\n          history={history}\r\n          location={location}\r\n          match={match}\r\n        />,\r\n        {\r\n          initialState:mockStore\r\n        }\r\n      );\r\n    })\r\n  })\r\n\r\n  afterEach(cleanup);\r\n\r\n  afterAll((done) => {\r\n    done();\r\n  });\r\n\r\n  //Component renders without crashing.\r\n  it('renders without crashing',async()=>{\r\n    expect(difficultySelection.toJSON()).toMatchSnapshot();\r\n  })\r\n\r\n  //Test easy selection.\r\n  it(`correctly initializes board when the easy button is selected`, async ()=>{\r\n    const {getByTestId, store} = difficultySelection;\r\n    const easyButton = getByTestId('easyButton');\r\n    const curHistory:number = history.length;\r\n    //Press easy button\r\n    fireEvent.press(easyButton);\r\n    await waitFor(()=>{\r\n      //History length should increase by 1.\r\n      expect(history.length).toBe(curHistory + 1);\r\n      //Location pathname should be 'GameDisplay'.\r\n      expect(history.location.pathname).toBe('/GameDisplay');\r\n      //Determine the amount of non-null values on the initialized board.\r\n      const boardState:(number | null)[][] = store.getState().board;\r\n      let valueCount:number = 0;\r\n      boardState.forEach((arr) =>{\r\n        arr.forEach((num)=>{\r\n          if(num !== null) valueCount += 1;\r\n        })\r\n      })\r\n      //Board should be initialized with (37,46) non-null values.\r\n      expect(valueCount >= 37 && valueCount <= 46).toBeTruthy();\r\n    })\r\n  })\r\n\r\n  //Test medium selection.\r\n  it(`correctly initializes board when the medium button is selected`, async ()=>{\r\n    const {getByTestId, store} = difficultySelection;\r\n    const mediumButton = getByTestId('mediumButton');\r\n    const curHistory:number = history.length;\r\n    //Press medium button.\r\n    fireEvent.press(mediumButton);\r\n    await waitFor(()=>{\r\n      //History length should increase by 1.\r\n      expect(history.length).toBe(curHistory + 1);\r\n      //Location pathname should be 'GameDisplay'.\r\n      expect(history.location.pathname).toBe('/GameDisplay');\r\n      //Determine the amount of non-null values on the initialized board.\r\n      const boardState:(number | null)[][] = store.getState().board;\r\n      let valueCount:number = 0;\r\n      boardState.forEach((arr) =>{\r\n        arr.forEach((num)=>{\r\n          if(num !== null) valueCount += 1;\r\n        })\r\n      })\r\n      //Board should be initialized with (27,36) non-null values.\r\n      expect(valueCount >= 27 && valueCount <= 36).toBeTruthy();\r\n    })\r\n  })\r\n\r\n  //Test hard selection.\r\n  it(`correctly initializes board when the hard button is selected`, async ()=>{\r\n    const {getByTestId, store} = difficultySelection;\r\n    const hardButton = getByTestId('hardButton');\r\n    const curHistory = history.length;\r\n    //Press hard button\r\n    fireEvent.press(hardButton);\r\n    await waitFor(()=>{\r\n      //History length should increase by 1.\r\n      expect(history.length).toBe(curHistory + 1);\r\n      //Location pathname should be 'GameDisplay'.\r\n      expect(history.location.pathname).toBe('/GameDisplay');\r\n      //Determine the amount of non-null values on the initialized board.\r\n      const boardState:(number | null)[][] = store.getState().board;\r\n      let valueCount:number = 0;\r\n      boardState.forEach((arr) =>{\r\n        arr.forEach((num)=>{\r\n          if(num !== null) valueCount += 1;\r\n        })\r\n      })\r\n      //Board should be initialized with (19,26) non-null values.\r\n      expect(valueCount >= 19 && valueCount <= 26).toBeTruthy();\r\n    })\r\n  })\r\n\r\n  //Test extreme selection.\r\n  it(`correctly initializes board when the extreme button is selected`, async ()=>{\r\n    const {getByTestId, store} = difficultySelection;\r\n    const extremeButton = getByTestId('extremeButton');\r\n    const curHistory:number = history.length;\r\n    //Press hard button\r\n    fireEvent.press(extremeButton);\r\n    await waitFor(()=>{\r\n      //History length should increase by 1.\r\n      expect(history.length).toBe(curHistory + 1);\r\n      //Location pathname should be 'GameDisplay'.\r\n      expect(history.location.pathname).toBe('/GameDisplay');\r\n      //Determine the amount of non-null values on the initialized board.\r\n      const boardState:(number | null)[][] = store.getState().board;\r\n      let valueCount:number = 0;\r\n      boardState.forEach((arr) =>{\r\n        arr.forEach((num)=>{\r\n          if(num !== null) valueCount += 1;\r\n        })\r\n      })\r\n      //Board should be initialized with 18 non-null values.\r\n      expect(valueCount).toBe(18);\r\n    })\r\n  })\r\n\r\n  //Test main menu button.\r\n  it(`should route to the home screen when the 'Main Menu' button is selected`, ()=>{\r\n    const {getByTestId} = difficultySelection;\r\n    const mainMenuButton = getByTestId('mainMenuButton');\r\n    const curHistory = history.length;\r\n    //Press 'Main Menu' button.\r\n    fireEvent.press(mainMenuButton);\r\n    //History length should increase by 1.\r\n    expect(history.length).toBe(curHistory + 1);\r\n    //Location pathname should be '/'.\r\n    expect(history.location.pathname).toBe('/');\r\n  })\r\n\r\n})"},"C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\__tests__\\renderWithRedux.tsx":{"modulePaths":["C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\redux\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\redux-thunk\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@types\\react-redux\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\state\\reducers\\index.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\node_modules\\@testing-library\\react-native\\typings\\index.d.ts","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\types.tsx","C:\\Users\\ashee\\Documents\\Javascript\\React\\React Native\\suduko\\src\\state\\reducers\\index.ts"],"testFileContent":"import React from 'react';\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport thunk from 'redux-thunk';\r\nimport { Provider } from 'react-redux';\r\nimport reducers from '../state/reducers/index';\r\nimport { render } from '@testing-library/react-native';\r\nimport {RenderReduxAPI} from '../../types'\r\nimport {RootState} from '.././state/reducers/index'\r\n//Function to provide mockStore for components managed by redux.\r\nexport default function renderWithRedux(\r\n  component:JSX.Element,\r\n  {initialState,store = createStore(reducers,initialState,applyMiddleware(thunk))}:RootState = {}\r\n  ):RenderReduxAPI{\r\n  return {\r\n    ...render(<Provider store = {store}>{component}</Provider>),\r\n    store\r\n  }\r\n}"}}